#include <iostream>

// Casts between base and derived classes

// Мы хотим, чтобы объекты наследника вели себя отчасти как объекты родителей отчасти
// То есть это означает, что если мы создали объект наследника

struct GrandBase
{
};

struct Base : public GrandBase
{
    int a = 0;
    Base() = default;
    Base(const Base &)
    {
        std::cout << "a";
    }
};

struct Derived : public Base
{
    int a = 1;
    Derived() = default;
};

void f1(Base &b) // с указателем и ссылкой это работает
{
    std::cout << b.a << '\n';
}

void f2(Base *b) // с указателем и ссылкой это работает
{
    std::cout << b->a << '\n';
}

void f3(Base b) // со значением тоже работает, однако тут будет полноценная копия от родительской части, которая будет рабоать через конструктор копирования
{
    std::cout << b.a << '\n';
}

struct A {};

struct B : private A {};

int main()
{
    Derived d;
    f1(d); // Неявный каст между ссылками.
    // derived скастуется к base и будет выводить поле родителя, то есть  0
    // Распространненой способ использовать наследника как родителя. Наследник - частный случай родителя

    f2(&d); // Неявный каст указателей наследника к родителю.
    // Каст по иеархии вверх. Как от наследника к родителю разрешен.

    // А что будет если сделать и вызвать функцию, которая принимает по значению. А не по указателю и не по
    // ссылке.
    f3(d);

    Base &b = d; // Будет только родительская часть, только Base. То есть сначала лежить Base, а рядом будет лежать
    // его надстройка derive
    std::cout << sizeof(b) << '\n'; // Будет 4, так как тут лежить 1 int из Base
    std::cout << sizeof(d) << '\n'; // Будет 8, так как тут будет храниться два типа int из base и derived
    Base b1 = d;                    // Будет вызван конструктор копирования из родителского класса Base
    // физически b и d  это одно и тоже, однако со стороны компилятора это одни и те же вещи

    // Аналогично будет работать при вложеном наследовании
    GrandBase &b2 = d;
    std::cout << sizeof(b2) << '\n'; // будет размер 1, так как не бывает объекты размера 0

    std::cout << sizeof(b2) << '\n'; // будет размер 1, так как не бывает объекты размера 0

    // Empty base optimization
    // [][ base ][ derived ]
    // Если бы GrandBase был бы как отдельный класс . Если привести его к наследованию, и будет чьим-то родителем, то он будет первым байтом в наследнике
    std::cout << sizeof(d) << '\n'; // Однако d будет 8 а не 9 байт, так как будет emty base optimizationS
    // В том, что все лежит по соседству можно сделать с помощью [][ base ][ derived ]:
    std::cout << *(&b.a + 1) << '\n'; // Будет лежать a из derived

    // как сделать каст в обратную сторону из base, если он сначала был из derived скастован, в derived
    // Derived & dd = b; // так нельзя делать обратный каст. Аналогично и с указателем
    // Как все-таки сделать, можно сделать static_cast
    Derived &dd = static_cast<Derived &>(b); // Только к указателям или ссылкам
    Derived *ddd = static_cast<Derived *>(&b);
    std::cout << dd.a << '\n'; // Плохой стиль

    // Однако static_cast не позволяет кастовать классы не имеющие общую иеархию и приватное/протектед наследование. Вдоль одного пути наследования
    // Приватное наследование
    B b;
    A& a = b; // Так как класс а приватный, то нельзя так делать, так как приватный наследник о нем не должен знать 
    // reinterpret_cast позволяет не соблюдая приваетность 
    A & a = reinterpret_cast<A&>(b); // Приватность будет игнорироваться :)
    // Или грязным c-style cast
    A & a = (A&)(b); // Потому что он проверяет, что если static_cast не сработал, то пытаемся reinterpret_cast 

    return 0;
}