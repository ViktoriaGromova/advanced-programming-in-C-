#include <iostream>

// Virtual inheritance
// Есть проблема ромбовидного наследование. И чтобы при множественном наследовании такой проблемы не было, используют виртуальное наследование.
// Наследование при которорм, компилятор не создает копию базового класса, если он был уеаследован кем-то в иеархии до вас. 
// Наследование, при котором не создается  дважды копия одного и того же базового класса, который был виртуально унаследован.

struct Granny
{
    int g = 1;
};

struct Dad: public virtual Granny // будет одна копия гренни, а не две
{
    int d = 2;
};

struct Mom: public virtual Granny
{
    int m = 2;
};

struct Son: public Mom, public Dad{
    int s = 3;
};

int main(){
    Son s;
    s.g;
    // Чем плохо виртуальное наследование. Какие проблемы имеются. Как это будет распалагаться в памяти
    // когда, при наследовании мы пишем vitrual, то мы говорим, а не наследуй нам предка
    // Рассмотрим как это должно лежать [ Mom::g ][ Mom::m ](указатель, где лежит g)[ Dad::d ][ Son::s ]
    //  Посчитаем размер Son:
    std::cout << sizeof(s)  << std::endl; // 40 покажет, хотя при обычном наследовании был 20. Начало указателей лежит на granny
    // Если у вас наследование виртуальное, то предку нужно знать, где его база, потому что она может располагаться вне его начале.
    // Если мы расписываем такое наследование и пишем
    Dad *d = &s;
    d->g; // У папы нет теперь g, и тут должен лежать указатель, где лежит g 
    // В памяти лежит так: базу вы кладете отдельно: а в наследование вы кладете указатель [ Mom_ptr ][ Mom::m ]....[ Dad_ptr ][ Dad::d ][ Son::s ][Granny::g] - лежит так, чтобы не происходили сдвиги

    // Рассмотри какие адресса у g:
    std::cout << &s.Dad::g << " " << &s.Mom::g << " "<< &s.Mom::m << " "<< &s.Dad::d << " "<< &s.s << std::endl; 
    // 0x7ffe11e53260 0x7ffe11e53260 0x7ffe11e53248 0x7ffe11e53258
    // Размер струкутур зависит выравнивается по самомму большому полю
    // Приведение типов зато работает корректно 
    Granny& g = s; //Будет сдвиг на 36 
    // Виртуальное наследование плохо тем, что тут каждое приведение типов, делает огромный прыжок, и нужно бегать и смотреть
    // объекты лежат не цельным куском
    return 0;
}