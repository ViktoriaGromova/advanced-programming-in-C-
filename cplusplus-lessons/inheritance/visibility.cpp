# include <iostream>

// Видимость и доступность
// Visibility and accessibility

struct Mom
{
    int a = 0;
    void f()
    {
        std::cout << "Mom\n";
    }
};

struct Son : Mom
{
    int a = 1;
    void f()
    {
        std::cout << "Son\n";
    }
};

struct Daughter : Mom
{
private:
    int a = 2;
    void f()
    {
        std::cout << "Daughter\n";
    }
};

struct step_Mom
{
    int a = 0;
    void f(double)
    {
        std::cout << "step-Mom\n";
    }
    step_Mom(int a) : a(a) {} // using кострукторы. Можно в step_Daughter, можно вызвать конструктор из Mom 
};

struct step_Daughter : step_Mom
{
    // Можно внести в класс родительскю функцию функцию , чтобы ее можно было вызвать в step_Daughter 
    using step_Mom::f; // Однако, если бы это было приватным, то было SE
    int a = 2;
    using step_Mom::step_Mom; // конструктор в step_Daughter, который использует step_Mom 
    void f(int)
    {
        std::cout << "step-Daughter\n";
    }
};

// Можно делать с c++11 using конструкторы
// конуструкторы, если хотим использовать поле 

int main()
{
    Son s;
    s.f(); // Будет вызвана функция из Mom, так как он более локальный
    // Можно попросить явно указать версию предка
    s.Mom::f();       // Вызвать функцию из Mom
    std::cout << s.a; // Будет значение сына
    std::cout << s.Mom::a; // Будет значение мамы

    // SE 
    Daughter d;
    std::cout << d.a; // Доступность проверяется после выбора видимой переменной, поэтому мне не будет доступны переменные от мамы
    // Если не указана версия класса, которая должна быть в коде, то берется все значения, которые реализации которых наследуются
    // и наследник перекрывает все другие методы. 

    // Всегда в области видимости самая послежlяя реализация, которая перекрывает родительские. Они не доступны напрямую.
    step_Daughter s_d;
    std::cout << s_d.f(0.0); // Тут будет неявный каст из 0.0 в 0, чтобы использовать дочерние, последние 
    // версии кода.
    // Выбор кандидатов функции выбирается раньше, чем приведение типов.

    // Использование using конструкторов. 
        step_Daughter s_d(3); // Вызывается конструктор из step_Mom, который инициализирует значения из step_Mom, а 
    // дочернем классе будут значения по-умолчанию  

}